(?# Match factorial numbers in the domain ^x*$ )
^
(?=
	(?*(x(x*)))                         (?# \1 = conjectured for which \1! == tail; \2 = \1-1 )
	(?!
		(?*.*(?=\1$)(x+))               (?# \3 = any number <= \1 )
		(?!\3+$)                        (?# there is no \3 that doesn't divide tail )
	)
	(
		(?=
			(?=(x(x(x*?)))\5+$)                       (?# \5 = smallest prime factor; \6 = \5-1; \7 = \6-1 )
			(?=
				(?*(x(x+)))                           (?# \8 = largest prime power factor corresponding to \5; \9 = \8-1 )
				\8*(?=\8$)
				(?!                                   (?# Assert that there is no prime \11 that divides \8 and isn't equal to \5,
                                                          and that it's also not true that \8 is prime and isn't equal to \5)
					((xx+)\11*(?=\11$))?
					(?!(xx+)\12+$|\5$)
				)
			)
		)
		(?=
			.*?(?!\1.)
			(                           (?# \13 = largest power of \5 less than or greater than \1 )
				(                       (?# Assert that tail is a power of \5 )
					(?=                 (?# Divide: \15 = tail / \5, with \16 = \15-1 )
						(x(x*))
						(?=\15*$)       (?# Testing for divisibility by \6 here isn't necessary, as tail is a power of \5 )
						(\6\16+$)       (?# \17 = tool to make the tail equal \15 )
					)\17
				)*x$
			)
		)
		(?=
			.*(?=\8\13$)                                    (?# Seed the loop )
			(
				(?# The first thing we need to do every iteration is decode the current number back into two prime powers,
					\19 and \23, where \19 is the smaller one, if they are different )
				(?=
					(x(x*?))                                (?# \19 = smaller prime power; \20 = \19-1 )
					(?!((x+)(?=\22+$)x+)\21*(?!\22+$)\21$)  (?# Assert that tail is a prime power)
					(\5+|x)$                                (?# \23 = larger prime power )
				)
				(?=
					.*?(?!\1.)                              (?# discard the remainder )
					(?=\19*$)                               (?# discard the remainder )
					(x(x*))                                 (?# \24 = floor{\1 / \19}; \25 = \24-1 )
					(?=\24*$)
					(?=\20+$)
					\20\25*$
				)
				(?# construct \5 ^ \24 by taking logarithm in base \5 and matching it against \24 )
				(?=
					.*
					(?=
						(                                   (?# Assert that tail is a power of \5 )
							(?=                             (?# Divide: \27 = tail / \5, with \28 = \27-1 )
								(x(x*))
								(?=\27*$)                   (?# Testing for divisibility by \6 here isn't necessary, as tail is a power of \5 )
								(\6\28+$)                   (?# \29 = tool to make the tail equal \27 )
							)\29
						)*x$
					)
					(?=(x(x*$)))                            (?# \30 = tail, what is to be \5 ^ \24; \31 = \30-1 )
					(?=(x*)\32(x?))                         (?# \32 = floor{tail / 2}, \33\32 = ceil{tail / 2}, \33 = tail % 2 )
					(?=
						(                                       (?# \34 = logarithm in base \5 of tail )
							x                                   (?# seed the loop )
							(?=
								(
									(?=
										(x*)\33(?=\32)          (?# tail = \32;  \36 = tool for decoding current state )
										\36                     (?# tail = current encoded state )
										(x*?)                   (?# \37 = iteration count )
										(?=
											(                   (?# Assert that tail is a power of \5 )
												(?=             (?# Divide: \39 = tail / \5, with \40 = \39-1 )
													(x(x*))
													(?=\39*$)   (?# Testing for divisibility by \6 here isn't necessary, as tail is a power of \5 )
													(\6\40+$)   (?# \41 = tool to make the tail equal \39 )
												)\41
											)*x$
										)
										(x(x*))                 (?# \42 = tail = A ^ {iteration count + 1}; \43 = \42-1 )
									)
									(?# encode state for next loop iteration, so that \37 will be incremented and \42 will be doubled )
									(?=
										(?# commence multiplication of \42 * \6; since we don't know which
											of \6 and \42 is larger/smaller, do two symmetric tests )
										.*
										(?=\42*$)
										(?= \6*$)
										(?=\42\7+$)
										(  \6\43+$)             (?# \44 = \42 * \6 )
									)
									x\44                        (?# tail -= \42 * \6 + 1 )
								)+
							)
							x\37                                (?# Return logarithm in base A of B )
						|                                       (?# The main algorithm can't handle B<=A, so handle that below )
							x?\B                                (?# If B>1 return a value of 1, otherwise return a value of 0 )
						)
					)
					(?=
						.*(?=\34$)\24$                          (?# Assert that \34, the logarithm, equals \24 )
					)
				)
				(?=
					.*(?=\23$)
					(x(x*))                               (?# \45 = \23 / \30; \46 = \45-1 )
					(?=\45*$)
					(?=\31+$)
					\31\46*$
				)
				(?=
					.*(?=\19$)
					(x(x*))                               (?# \47 = \19 / \5; \48 = \47-1 )
					(?=\47*$)
					(?=\6+$)
					\6\48*$
				)
				.*(?=\45\47$)
			)*
			xx$
		)
		(?=
			(x(x*))                           (?# \49 = tail / \8; \50 = \47-1 )
			(?=\49*$)
			(?=\9+$)
			(\9\50*$)                         (?# \51 = tool for making tail equal \49 )
		)\51
	)*
	(?!\1.)                                   (?# Assert that the remaining factor is <= \1 )
	(?!(xx+)\52+$)                            (?# Assert that the remaining factor is prime )
)
\1