# Match abundant numbers in the domain ^x*$ using only the ECMAScript subset of regex functionality.
# For the purposes of these comments, the input number = N.
^
# Capture the largest prime factor of N, and the largest power of that factor that is also a factor of N. Note that the
# algorithm used will fail if N itself is a prime power, but that's fine, because prime powers are never abundant.
(?=
    (                                # \1 = tool to make tail = Z-1
        (                            # Repeatedly divide current number by its smallest factor.
            (?=(xx+?)\3+$)
            (x+)\4*(?=\4$)
        )+                           # A "+" is intentionally used instead of a "*", to fail if N is prime. This saves the rest
                                     #  of the regex from having to do needless work, because prime numbers are never abundant.
        (?!\3+$)                     # Require that the last factor divided out is a different prime.
        (?=(xx(x*?))\5*$)            # \5 = the largest prime factor of N; \6 = \5-2
        x                            # An extra 1 so that the tool \1 can make tail = Z-1 instead of just Z
    )
    (x+)                             # Z = the largest power of \5 that is a factor of N; \7 = Z-1
)
# We want to capture Z + Z/\5 + Z/\5^2 + ... + \5^2 + \5 + 1 = (Z * \5 - 1) / (\5 - 1), but
# in case Z * \5 > N we need to calculate it as (Z - 1) / (\5 - 1) * \5 + 1.
# The following division will fail if Z == N, but that's fine, because no prime power is abundant.
(?=
    \1                               # tail = (Z - 1)
    (x(x*))                          # \8   = (Z - 1) / (\5 - 1); \9 = \8-1
    # it is guaranteed that either \8 > \5-1 or \8 == 1, which allows the following division-by-multiplication to work
    (?=\8*$)
    \6\9+$
)
(?=
    (.*)                             # \10 = tool to compare against \11
    (                                # \11 = \8 * \5  =  (Z - 1) / (\5 - 1) * \5; later, \13 = \11 + 1
        (?=\8*$)
        \5\9+$
    )
)
# Calculate Q = \15{2} + Q_R = floor(2 * N / \13). Since we don't have space for 2 * N, we need to calculate N / \13 first,
# including the fractional part (i.e. the remainder), and then multiply the result, including the fractional part, by 2.
(?=
    (x*?)(?=(x\11)+$)                # \12 = N % \13; \13 = \11 + 1
    (?=\12\10|(x))                   # \14 = Q_R = floor(\12 * 2 / \13) == +1 carry if \12 * 2 > \11, or NPCG otherwise
    (x(x*))                          # \15 = N / \13; \16 = \15-1
    (?=\15*$)
    (?=\11+$)                        # must match if \15 <  \13; otherwise doesn't matter
    \11\16+$                         # must match if \15 >= \13; otherwise doesn't matter
)
# Calculate \17 = N / Z. The division by Z can be done quite simply, because the divisor is a prime power.
(?=
    (x(x*))                          # \17 = N / Z; \18 = \17-1
    (?=\17*$)
    \7\18+$
)
# Seed a loop which will start with Q and divide it by (P^(K+1)-1)/(P-1) for every P^K that is a
# factor of \17. The state is encoded as \17 * P + R, where the initial value of R is Q, and P is
# the last prime factor of N to have been already processed.
#
# However, since the initial R would be larger than \17 (and for that matter there would be no room
# for any nonzero R since with the initial value of P, it is possible for \17 * P to equal N), treat
# it as a special case, and let the initial value of R be 0, signalling the first iteration to
# pretend R=Q. This way we can avoid having to divide Q and \17 again outside the loop.
#
# While we're at it, there's really no reason to do anything extra to seed this loop. To seed it
# with an initial value of P=\5, we'd have to do some multiplication. If we don't do anything to
# seed it, it will decode P=Z. That is wrong, but harmless, since the next lower prime that \17
# is divisible by will still be the same, as \5 cannot be a factor of \17.

# Start the loop.
(
    (?=
        (                            # \20 = actual value of R
            x*?(?=\17+$)             # move forward by directly decoded value of R, which can be zero
            # The division by \17 can be done quite simply, because it is known that the quotient is prime.
            (?=
                \17+?                # tail = \17 * {a prime which divides into \17}
                (?=
                    (                # \21 = encoded value for next loop iteration
                        (xx(x*))     # \22 = decoded value of next smaller P; \23 = (\22-1)-1
                        (?=\18+$)    # iff \22 > \17, this can have a false positive, but never a false negative
                        \22*$        # iff \22 < \17, this can have a false positive, but never a false negative
                    )
                )
                # Find the largest power of \22 that is a factor of \17, while also asserting that \22 is prime
                (x+)                 # \24 = the largest power of \22 that is a factor of \17
                .*(?=\17$)
                \24*(?=\24$)
                (?!
                    (xx+)\25*
                    (?!\22+$)
                    \25$
                )
                \22+$
            )
            (
                (?=(x\7)+$)          # true iff this is the first iteration of the loop
                \15{2}\14?           # "\14?" so that iff it's a NPCG it acts as empty with both ECMAScript and PCRE behavior
            |
            )
        )
    )
    # Calculate \30 = (\24 - 1) / (\22 - 1) * \22 + 1
    (?=
        .*(?=\24)x                   # tail = \24 - 1
        (x(x*))                      # \28 = (\24 - 1) / (\22 - 1); \29 = \28-1
        (?=\28*$)
        \23\29*$
    )
    (?=
        .*(x(                        # \30 = 1 + \28 * \22 = (\28 - 1) / (\22 - 1) * \22 + 1; \31 = \30-1
            (?=\28*$)
            \22\29+$
        ))
    )
    # Calculate \33 = floor(\20 / \30)
    (
        .*(?!\30)\20                 # If dividing \20 / \30 would result in a number less than 1,
                                     # then N is abundant and we can exit the loop successfully.
    |
        (?=
            .*?(?!x\20)(?=\30*$)
            (x(x*))                  # \33 = \20 / \30; \34 = \33-1
            (?=\33*$)
            (?=\31+$)                # must match if \33 <  \30; otherwise doesn't matter
            \31\34+$                 # must match if \33 >= \30; otherwise doesn't matter
        )
        # Encode the state for the next iteration of the loop, as \17 * \22 + \33
        .*(?=\33\21$)
    )
)+$