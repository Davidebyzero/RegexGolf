(?# Match abundant numbers in the domain ^x*$ using only the ECMAScript subset of regex functionality. )
(?# N = main number )
^
(?# Capture the largest prime factor of N, and the largest power of that factor that is also a factor of N. Note that the
    algorithm used will fail if N itself is a prime power, but that's fine, because prime powers are never abundant. )
(?=
    (?:                              (?# Repeatedly divide current number by its smallest factor )
        (?=(xx+?)\1+$)
        (x+)\2*(?=\2$)
    )+                               (?# A "+" is intentionally used instead of a "*", to fail if N is prime. This saves the rest
                                         of the regex from having to do needless work, because prime numbers are never abundant. )
    (?!\1+$)                         (?# require that the last factor divided out is a different prime )
    (?=(x(x+?))\3*$)                 (?# \3 = the largest prime factor of N; \4 = \3-1 )
    (x(x+))                          (?# \5 = the largest power of \3 that is a factor of N; \6 = \5-1 )
)
(?# We want to capture \5 + \5/\3 + \5/19^2 + ... + \3^2 + \3 + 1 = {\5 * \3 - 1} / {\3 - 1}, but
    in case \5 * \3 > N we need to calculate it as {\5 - 1} / {\3 - 1} * \3 + 1. )
(?# The following division will fail if \5 == N, but that's fine, because no prime power is abundant. )
(?=
    (x(x*))                          (?# \7 = {\5 - 1} / \4; \8 = \7-1 )
    .*(?=\6$)
    (?# it is guaranteed that either \7 > \4 or \7 == 1, which allows the following division-by-multiplication to work )
    .*(?=\7*$)
    \4\8+$
)
(?=
    .*(x(                            (?# \9 = 1 + \7 * \3  =  {\5 - 1} / {\3 - 1} * \3 + 1;  \10 = \9-1 )
        (?=\7*$)
        \3\8+$
    ))
)
(?# Calculate Q = \13{2} + Q_R = 2 * N / \9. Since this might be > N / 2, we need to calculate N / \9 first, including
    the fractional part {i.e. the remainder}, and then multiply the result, including the fractional part, by 2. )
(?=
    (?=\9(x*))                       (?# \11 )
    (x*)(?=x\11)                     (?# \12 = N % \9 )
    (?=\9*$)
    (x(x*))                          (?# \13 = N / \9; \14 = \13-1 )
    (?=\13*$)
    (
        (?=.*(?=\13$)\9)             (?# what to do if \13 >= \9 )
        (?=
            (\13*)                   (?# \16 )
            \10\14+$
        )
        .*$\16
    |
        (?!.*(?=\13$)\9)             (?# what to do if \9 > \13 )
        \10+$
    )
)
(?# Calculate \17 = N / \5 )
(?=
    (x(x*))                          (?# \17 = N / \5; \18 = \17-1 )
    (?=\17*$)
    (
        (?=.*(?=\17$)\5)             (?# what to do if \17 >= \5 )
        (?=
            (\17*)                   (?# \20 )
            \6\18+$
        )
        .*$\20
    |
        (?!.*(?=\17$)\5)             (?# what to do if \5 > \17 )
        \6+$
    )
)
(?# Seed a loop which will start with Q and divide it by {P^{K+1}-1}/{P-1} for every P^K that is a
    factor of \17. The state is encoded as \17 * P + R, where the initial value of R is Q, and P is
    the last prime factor of N to have been already processed.
    
    However, since the initial R would be larger than \17 {and for that matter there would be no room
    for any nonzero R since with the initial value of P, it is possible for \17 * P to equal N}, treat
    it as a special case, and let the initial value of R be 0, signalling the first iteration to
    pretend R=Q. This way we can avoid having to divide Q and \17 again outside the loop.
    
    While we're at it, there's really no reason to do anything extra to seed this loop. We would have
    to seed it with an initial value of P=\3; if we don't do anything to seed it, it will decode P=\5,
    which is wrong because this will make it use P=\3 as the next prime when it needs to work on the
    next lower prime. So, we'll treat the first iteration as a special case for decoding P as well,
    making it behave as if P=\3 if the initially decoded R is 0, i.e. on the first iteration only. )

(?# Start the loop. )
(
    (?=
        (x*?)(?=\17*$)               (?# \22 = decoded value of R )
        (?# The division by \17 can be done quite simply, because it is known that the quotient is prime. )
        (x(x+))                      (?# \23 = decoded value of P; \24 = \23-1 )
        (?=\18+$)                    (?# iff \23 > \17, this can have a false positive, but never a false negative )
        \23*$                        (?# iff \23 < \17, this can have a false positive, but never a false negative )
    )
    (?=
        (x(x(x*)))                   (?# \25 = next value of P to work with; \26 = \25-1; \27 = \26-1 )
        .*(?=\17$)
        (?=
            \25*(?=\25$)             (?# assert that \25 is a factor of \17 )
            (?!
                \3|\23               (?# assert that \25 is less than the previous P )
            |
                (xx+)\28+$           (?# assert that \25 is prime )
            )
        )
        (?# Find the largest power of \25 that is a factor of \17 )
        (
            (?=\25+$)
        |
            (\25+)\30*(?=\30$)
        )
        (?!                          (?# Prime Powers test )
            ((x+)(?=\32+$)x+)
            \31*
            (?!\32+$)
            \31$
        )
        x(x*)                        (?# \33 = {the largest power of \25 that is a factor of \17} - 1 )
    )
    (?=
        (                            (?# \34 = actual value of R )
            (?=.*$\22)
            \13{2}
            (                        (?# add Q_R = \12 * 2 / \9 )
                (?=
                    .*(?=\9$)
                    \12{2}x
                )
            |
                x
            )
        |
            \22
        )
    )
    (?# Calculate \39 = \33 / {\25 - 1} * \25 + 1 )
    (?=
        .*(?=\33$)
        (x(x*))                      (?# \36 = {\33 - 1} / {\25 - 1}; \37 = \36-1 )
        (?=(\36*)\27\37*$)
        \36*$\38
    )
    (?=
        .*(x(                        (?# \39 = 1 + \36 * \25 = {\36 - 1} / {\25 - 1} * \25 + 1; \40 = \39-1 )
            (?=\36*$)
            \25\37+$
        ))
    )
    (?# Calculate \43 = \34 / \39 )
    (
        .*(?=\40$)\34.*$                     (?# if dividing \34 / \39 would result in a number less than 1,
                                                 then N is abundant and we can exit the loop successfully )
    |
        (?=
            .*(?=\34$)
            (?=\39(x*))                      (?# \42 )
            .*(?=x\42)
            (?=\39*$)
            (x(x*))                          (?# \43 = N / \39; \44 = \43-1 )
            (?=\43*$)
            (
                (?=.*(?=\43$)\39)            (?# what to do if \43 >= \39 )
                (?=
                    (\43*)                   (?# \46 )
                    \40\44+$
                )
                .*$\46
            |
                (?!.*(?=\43$)\39)            (?# what to do if \39 > \43 )
                \40+$
            )
        )
        (?# Encode the state for the next iteration of the loop )
        .*(?=
            \43
            (
                (?=.*(?=\17$)\25)            (?# what to do if \17 >= \25 )
                (?=(\17*)\25\18+$)
                \17*$\48
            |
                (?!.*(?=\17$)\25)            (?# what to do if \25 > \17 )
                (?=(\25*)\17\26+$)
                \25*$\49
            )
        )
    )
)+$
