(?# Match abundant numbers in the domain ^x*$ using only the ECMAScript subset of regex functionality. )
(?# N = main number )
^
(?# Capture the largest prime factor of N, and the largest power of that factor that is also a factor of N. Note that the
    algorithm used will fail if N itself is a prime power, but that's fine, because prime powers are never abundant. )
(?=
    (?:                              (?# Repeatedly divide current number by its smallest factor )
        (?=(xx+?)\1+$)
        (x+)\2*(?=\2$)
    )+                               (?# A "+" is intentionally used instead of a "*", to fail if N is prime. This saves the rest
                                         of the regex from having to do needless work, because prime numbers are never abundant. )
    (?!\1+$)                         (?# require that the last factor divided out is a different prime )
    (?=(x(x+?))\3*$)                 (?# \3 = the largest prime factor of N; \4 = \3-1 )
    (x(x+))                          (?# \5 = the largest power of \3 that is a factor of N; \6 = \5-1 )
)
(?# We want to capture \5 + \5/\3 + \5/19^2 + ... + \3^2 + \3 + 1 = {\5 * \3 - 1} / {\3 - 1}, but
    in case \5 * \3 > N we need to calculate it as {\5 - 1} / {\3 - 1} * \3 + 1. )
(?# The following division will fail if \5 == N, but that's fine, because no prime power is abundant. )
(?=
    (x(x*))                          (?# \7 = {\5 - 1} / \4; \8 = \7-1 )
    .*(?=\6$)
    (?# it is guaranteed that either \7 > \4 or \7 == 1, which allows the following division-by-multiplication to work )
    .*(?=\7*$)
    \4\8+$
)
(?=
    .*(x(                            (?# \9 = 1 + \7 * \3  =  {\5 - 1} / {\3 - 1} * \3 + 1;  \10 = \9-1 )
        (?=\7*$)
        \3\8+$
    ))
)
(?# Calculate Q = \13{2} + Q_R = 2 * N / \9. Since this might be > N / 2, we need to calculate N / \9 first, including
    the fractional part {i.e. the remainder}, and then multiply the result, including the fractional part, by 2. )
(?=
    (?=\9(x*))                       (?# \11 )
    (x*)(?=x\11)                     (?# \12 = N % \9 )
    (?=\9*$)
    (x(x*))                          (?# \13 = N / \9; \14 = \13-1 )
    (?=\13*$)
    (
        (?=.*(?=\13$)\9)             (?# what to do if \13 >= \9 )
        (?=
            (\13*)                   (?# \16 )
            \10\14+$
        )
        .*$\16
    |
        (?!.*(?=\13$)\9)             (?# what to do if \9 > \13 )
        \10+$
    )
)
(?# Calculate \18 = N / \5 )
(?=
    (                                (?# \17 = N, for testing for first iteration of loop below )
        (x(x*))                      (?# \18 = N / \5; \19 = \18-1 )
        (?=\18*$)
        (
            (?=.*(?=\18$)\5)         (?# what to do if \18 >= \5 )
            (?=
                (\18*)               (?# \21 )
                \6\19+$
            )
            .*$\21
        |
            (?!.*(?=\18$)\5)         (?# what to do if \5 > \18 )
            \6+$
        )
    )
)
(?# Seed a loop which will start with Q and divide it by {P^{K+1}-1}/{P-1} for every P^K that is a
    factor of \18. The state is encoded as \18 * P + R, where the initial value of R is Q, and P is
    the last prime factor of N to have been already processed.
    
    However, since the initial R would be larger than \18 {and for that matter there would be no room
    for any nonzero R since with the initial value of P, it is possible for \18 * P to equal N}, treat
    it as a special case, and let the initial value of R be 0, signalling the first iteration to
    pretend R=Q. This way we can avoid having to divide Q and \18 again outside the loop.
    
    While we're at it, there's really no reason to do anything extra to seed this loop. To seed it
    with an initial value of P=\3, we'd have to do some multiplication. If we don't do anything to
    seed it, it will decode P=\5. That is wrong, but harmless, since the next lower prime that \18
    is divisible by will still be the same, as \3 cannot be a factor of \18. )

(?# Start the loop. )
(
    (?=
        (                            (?# \23 = actual value of R )
            x*?(?=\18*$)             (?# move forward by directly decoded value of R, which can be zero )
            (?# The division by \18 can be done quite simply, because it is known that the quotient is prime. )
            (?=
                (x(x+))              (?# \24 = decoded value of P; \25 = \24-1 )
                (?=\19+$)            (?# iff \24 > \18, this can have a false positive, but never a false negative )
                \24*$                (?# iff \24 < \18, this can have a false positive, but never a false negative )
            )
            (
                (?=\17)              (?# true iff this is the first iteration of the loop )
                \13{2}
                (                    (?# add Q_R = \12 * 2 / \9 )
                    (?=
                        .*(?=\9$)
                        \12{2}x
                    )
                |
                    x
                )
            |
            )
        )
    )
    (?=
        (x(x(x*)))                   (?# \28 = next value of P to work with; \29 = \28-1; \30 = \29-1 )
        .*(?=\18$)
        (?=
            \28*(?=\28$)             (?# assert that \28 is a factor of \18 )
            (?!
                \24                  (?# assert that \28 is less than the previous P )
            |
                (xx+)\31+$           (?# assert that \28 is prime )
            )
        )
        (?# Find the largest power of \28 that is a factor of \18 )
        (
        |
            (\28+)\33*(?=\33$)
        )
        (?!                          (?# Prime Powers test )
            ((x+)(?=\35+$)x+)
            \34*
            (?!\35+$)
            \34$
        )
        x(x*)                        (?# \36 = {the largest power of \28 that is a factor of \18} - 1 )
    )
    (?# Calculate \40 = \36 / {\28 - 1} * \28 + 1 )
    (?=
        .*(?=\36$)
        (x(x*))                      (?# \37 = {\36 - 1} / {\28 - 1}; \38 = \37-1 )
        (?=(\37*)\30\38*$)
        \37*$\39
    )
    (?=
        .*(x(                        (?# \40 = 1 + \37 * \28 = {\37 - 1} / {\28 - 1} * \28 + 1; \41 = \40-1 )
            (?=\37*$)
            \28\38+$
        ))
    )
    (?# Calculate \44 = \23 / \40 )
    (
        .*(?=\41$)\23.*$                     (?# if dividing \23 / \40 would result in a number less than 1,
                                                 then N is abundant and we can exit the loop successfully )
    |
        (?=
            .*(?=\23$)
            (?=\40(x*))                      (?# \43 )
            .*(?=x\43)
            (?=\40*$)
            (x(x*))                          (?# \44 = N / \40; \45 = \44-1 )
            (?=\44*$)
            (
                (?=.*(?=\44$)\40)            (?# what to do if \44 >= \40 )
                (?=
                    (\44*)                   (?# \47 )
                    \41\45+$
                )
                .*$\47
            |
                (?!.*(?=\44$)\40)            (?# what to do if \40 > \44 )
                \41+$
            )
        )
        (?# Encode the state for the next iteration of the loop )
        .*(?=
            \44
            (
                (?=.*(?=\18$)\28)            (?# what to do if \18 >= \28 )
                (?=(\18*)\28\19+$)
                \18*$\49
            |
                (?!.*(?=\18$)\28)            (?# what to do if \28 > \18 )
                (?=(\28*)\18\29+$)
                \28*$\50
            )
        )
    )
)+$
