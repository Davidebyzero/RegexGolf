# Match abundant numbers in the domain ^x*$ using only the ECMAScript subset of regex functionality.
# For the purposes of these comments, the input number = N.
^
# Capture the largest prime factor of N, and the largest power of that factor that is also a factor of N. Note that the
# algorithm used will fail if N itself is a prime power, but that's fine, because prime powers are never abundant.
(?=
    (                                # Repeatedly divide current number by its smallest factor.
        (?=(xx+?)\2+$)
        (x+)\3*(?=\3$)
    )+                               # A "+" is intentionally used instead of a "*", to fail if N is prime. This saves the rest
                                     #  of the regex from having to do needless work, because prime numbers are never abundant.
    (?!\2+$)                         # Require that the last factor divided out is a different prime.
    (?=(xx(x*?))\4*$)                # \4 = the largest prime factor of N; \5 = \4-2;
                                     # Z = tail == the largest power of \4 that is a factor of N
    x                                # tail -= 1
    (                                # \6 = tail == Z-1
        # We want to capture Z + Z/\4 + Z/\4^2 + ... + \4^2 + \4 + 1 = (Z * \4 - 1) / (\4 - 1), but
        # in case Z * \4 > N we need to calculate it as Y = (Z - 1) / (\4 - 1) * \4 + 1.
        # The following division will fail if Z == N, but that's fine, because no prime power is abundant.
        (x(x*))                      # \7 = (Z - 1) / (\4 - 1); \8 = \7-1
        # it is guaranteed that either \7 > \4-1 or \7 == 1, which allows the following division-by-multiplication to work
        (?=\7*$)
        \5\8+$
    )
)
# Calculate Q = \12{2} + Q_R = floor(2 * N / Y). Since we don't have space for 2 * N, we need to calculate N / Y first,
# including the fractional part (i.e. the remainder), and then multiply the result, including the fractional part, by 2.
(?=
    (x*?)                            # \9  = N % Y
    (?=(x(\6\7))+$)                  # \11 = Z-1 + (Z - 1) / (\4 - 1) == (Z - 1) / (\4 - 1) * \4 == Y-1
    (x(x*))                          # \12 = N / Y; \13 = \12-1
    (?=\12*$)
    (?=\11+$)                        # must match if \12 <  Y; otherwise doesn't matter
    \13+
    (?=\9\9|(x))                     # \14 = Q_R = floor(\9 * 2 / Y) == +1 carry if \9 * 2 > \11, or NPCG otherwise
    \11$                             # must match if \12 >= Y; otherwise doesn't matter (except to set tail for the
                                     #  Q_R calculation above)
)
# Calculate \15 = N / Z. The division by Z can be done quite simply, because the divisor is a prime power.
(?=
    (x(x*))                          # \15 = N / Z; \16 = \15-1
    (?=\15*$)
    \6\16+$
)
# Seed a loop which will start with Q and divide it by (P^(K+1)-1)/(P-1) for every P^K that is a
# factor of \15. The state is encoded as \15 * P + R, where the initial value of R is Q, and P is
# the last prime factor of N to have been already processed.
#
# However, since the initial R would be larger than \15 (and for that matter there would be no room
# for any nonzero R since with the initial value of P, it is possible for \15 * P to equal N), treat
# it as a special case, and let the initial value of R be 0, signalling the first iteration to
# pretend R=Q. This way we can avoid having to divide Q and \15 again outside the loop.
#
# While we're at it, there's really no reason to do anything extra to seed this loop. To seed it
# with an initial value of P=\4, we'd have to do some multiplication. If we don't do anything to
# seed it, it will decode P=Z. That is wrong, but harmless, since the next lower prime that \15
# is divisible by will still be the same, as \4 cannot be a factor of \15.

# Start the loop.
(
    (?=
        (                            # \18 = actual value of R
            x*?(?=\15*$)             # move forward by directly decoded value of R, which can be zero
            # The division by \15 can be done quite simply, because it is known that the quotient is prime.
            (?=
                (x+)                 # \19 = decoded value of P
                (?=\16+$)            # iff \19 > \15, this can have a false positive, but never a false negative
                \19*$                # iff \19 < \15, this can have a false positive, but never a false negative
            )
            (
                (?=(x\6)+$)          # true iff this is the first iteration of the loop
                \12{2}
                \14                  # potentially unset capture, and thus dependent on ECMAScript behavior
            |
            )
        )
    )
    (?=
        (                            # \22 = tool to make tail = {the largest power of \23 that is a factor of \15}
            (xx(x*))                 # \23 = next value of P to work with; \24 = (\23-1)-1
            .*(?=\15$)
            (?=
                \23*                 # along with the "\23$" below, assert that \23 is a factor of \15
                (?!\19)              # assert that \23 is less than the previous P
                \23$                 # along with the "\23*" above, assert that \23 is a factor of \15
            )
            # Find the largest power of \23 that is a factor of \15, while also asserting that \19 is prime
            (
            |
                (x+)\26*(?=\26$)
            )
            (?!
                (xx+)\27*
                (?!\23+$)
                \27$
            )
        )
        \23+$                        # assert that tail == the largest power of \23 that is a factor of \15
    )
    # Calculate \30 = ({the largest power of \23 that is a factor of \15} - 1) / (\23 - 1) * \23 + 1
    (?=
        \22x                         # tail = {the largest power of \23 that is a factor of \15} - 1
        (x(x*))                      # \28 = ({the largest power of \23 that is a factor of \15} - 1) / (\23 - 1); \29 = \28-1
        (?=\28*$)
        \24\29*$
    )
    (?=
        .*(x(                        # \30 = 1 + \28 * \23 = (\28 - 1) / (\23 - 1) * \23 + 1; \31 = \30-1
            (?=\28*$)
            \23\29+$
        ))
    )
    # Calculate \32 = floor(\18 / \30)
    (?=
        .*?(?!x\18)(?=\30*$)
        (x(x*))                  # \32 = \18 / \30; \33 = \32-1
        (?=\32*$)
        (?=\31+$)                # must match if \32 <  \30; otherwise doesn't matter
        \31\33+$                 # must match if \32 >= \30; otherwise doesn't matter
    |
    )
    # Encode the state for the next iteration of the loop, as \15 * \23 + \32
    (?=
        \32
        (x*)(?=\15*$)            # tail = \15 * \23; \34 = tool to make tail = \15 * \23 + \32
        (\23\16+$)               # \35 = tail
    )
    \34                          # tail = \15 * \23 + \32
)+
\35$