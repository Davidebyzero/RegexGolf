# Match abundant numbers in the domain ^x*$ using only the ECMAScript subset of regex
# functionality. For the purposes of these comments, the input number = N.
^
# Capture the largest prime factor of N, and the largest power of that factor that is
# also a factor of N. Note that the algorithm used will fail if N itself is a prime
# power, but that's fine, because prime powers are never abundant.
(?=
  (                      # Repeatedly divide current number by its smallest factor
    (?=(xx+?)\2+$)
    (x+)\3*(?=\3$)
  )+                     # A "+" is intentionally used instead of a "*", to fail if N
                         #  is prime. This saves the rest of the regex from having to
                         #  do needless work, because prime numbers are never abundant.
  (?!\2+$)               # Require that the last factor divided out is a different prime.
  (?=(xx(x*?))\4*$)      # \4 = the largest prime factor of N; \5 = \4-2;
                         # Z = tail = the largest power of \4 that is a factor of N
  x                      # tail -= 1
  (                      # \6 = tail == Z-1
    # We want to capture Z + Z/\4 + Z/\4^2 + ... + \4^2 + \4 + 1 = (Z * \4 - 1) / (\4 - 1),
    # but in case Z * \4 > N we need to calculate it as Y = (Z - 1) / (\4 - 1) * \4 + 1.
    # The following division will fail if Z == N, but that's fine, because no prime power is
    # abundant.
    (x(x*))              # \7 = (Z - 1) / (\4 - 1); \8 = \7-1
    # It is guaranteed that either \7 > \4-1 or \7 == 1, which allows the following
    # division-by-multiplication to work.
    (?=\7*$)
    \5\8+$
  )
)
# Calculate Q = \12{2} + Q_R = floor(2 * N / Y). Since we don't have space for 2*N, we
# need to calculate N / Y first, including the fractional part (i.e. the remainder),
# and then multiply the result, including the fractional part, by 2.
(?=
  (x*?)                  # \9  = N % Y
  (?=(x(\6\7))+$)        # \11 = Z-1 + (Z - 1) / (\4 - 1) == (Z - 1) / (\4 - 1) * \4 == Y-1
  (x(x*))                # \12 = N / Y; \13 = \12-1
  (?=\12*$)
  (?=\11+$)              # must match if \12 <  Y; otherwise doesn't matter
  \13+
  (?=\9\9|(x))           # \14 = Q_R = floor(\9 * 2 / Y)
                         #     = +1 carry if \9 * 2 > \11, or NPCG otherwise
  \11$                   # must match if \12 >= Y; otherwise doesn't matter
                         # (except to set tail for the Q_R calculation above)
)
# Calculate \15 = N / Z. The division by Z can be done quite simply, because the divisor
# is a prime power.
(?=
  (x(x*))                # \15 = N / Z; \16 = \15-1
  (?=\15*$)
  \6\16+$
)
# Seed a loop which will start with Q and divide it by (P^(K+1)-1)/(P-1) for every P^K
# that is a factor of \15. The state is encoded as \15 * P + R, where the initial value
# of R is Q, and P is the last prime factor of N to have been already processed.
#
# However, since the initial R would be larger than \15 (and for that matter there would
# be no room for any nonzero R since with the initial value of P, it is possible for
# \15 * P to equal N), treat it as a special case, and let the initial value of R be 0,
# signalling the first iteration to pretend R=Q. This way we can avoid having to divide Q
# and \15 again outside the loop.
#
# While we're at it, there's really no reason to do anything to seed this loop. To seed
# it with an initial value of P=\4, we'd have to do some multiplication. If we don't do
# anything to seed it, it will decode P=Z. That is wrong, but harmless, since the next
# lower prime that \15 is divisible by will still be the same, as \4 cannot be a factor
# of \15.

# Start the loop.
(
  (?=
    (                    # \18 = actual value of R
      x*?(?=\15+$)       # move forward by directly decoded value of R, which can be zero
      # The division by \15 can be done quite simply, because it is known that
      # the quotient is prime.
      (?=
        \15+?            # tail = \15 * (a prime which divides into \15)
        (?=
          (              # \19 = encoded value for next loop iteration
            (xx(x*))     # \20 = decoded value of next smaller P; \21 = (\20-1)-1
            (?=\16+$)    # iff \20 > \15, this can have a false positive, but never a false negative
            \20*$        # iff \20 < \15, this can have a false positive, but never a false negative
          )
        )
        # Find the largest power of \20 that is a factor of \15, while also asserting
        # that \20 is prime.
        (x+)             # \22 = the largest power of \20 that is a factor of \15
        .*(?=\15$)
        \22*(?=\22$)
        (?!
          (xx+)\23*
          (?!\20+$)
          \23$
        )
        \20+$
      )
      (
        (?=(x\6)+$)      # True iff this is the first iteration of the loop.
        \12{2}
        \14              # Potentially unset capture, and thus dependent on ECMAScript behavior.
      |
      )
    )
  )
  # Calculate \28 = (\22 - 1) / (\20 - 1) * \20 + 1
  (?=
    .*(?=\22)x           # tail = \22 - 1
    (x(x*))              # \26 = (\22 - 1) / (\20 - 1); \27 = \26-1
    (?=\26*$)
    \21\27*$
  )
  (?=
    .*(x(                # \28 = 1 + \26 * \20 = (\26 - 1) / (\20 - 1) * \20 + 1; \29 = \28-1
      (?=\26*$)
      \20\27+$
    ))
  )
  # Calculate \30 = floor(\18 / \28)
  (?=
    .*?(?!x\18)(?=\28*$)
    (x(x*))              # \30 = \18 / \28; \31 = \30-1
    (?=\30*$)
    (?=\29+$)            # must match if \30 <  \28; otherwise doesn't matter
    \29\31+$             # must match if \30 >= \28; otherwise doesn't matter
  |                      # If dividing \18 / \28 would result in a number less than 1,
                         # then N is abundant and we can exit the loop successfully.
                         # We signal this by leaving \30 unset (this relies on ECMAScript behavior)
  )
  # Encode the state for the next iteration of the loop, as \15 * \20 + \30
  .*(?=\30\19$)          # If \30 is unset, it will act as zero here. This will cause the next
                         # iteration of the loop to advance by zero, thus causing the loop to
                         # exit and reach the end condition successfully.
)+
\19$                     # N is abundant iff \30 was effectively zero in the last iteration.