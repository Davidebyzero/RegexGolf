# Match abundant numbers in the domain ^x*$ using only the ECMAScript subset of regex
# functionality. For the purposes of these comments, the input number = N.
^
# Capture the largest prime factor of N, and the largest power of that factor that is
# also a factor of N. Note that the algorithm used will fail if N itself is a prime
# power, but that's fine, because prime powers are never abundant.
(?=
  (?:                    # Repeatedly divide current number by its smallest factor
    (?=(xx+?)\1+$)
    (x+)\2*(?=\2$)
  )+                     # A "+" is intentionally used instead of a "*", to fail if N
                         #  is prime. This saves the rest of the regex from having to
                         #  do needless work, because prime numbers are never abundant.
  (?!\1+$)               # Require that the last factor divided out is a different prime.
  (?=(x(x+?))\3*$)       # \3 = the largest prime factor of N; \4 = \3-1
  (x(x+))                # \5 = the largest power of \3 that's a factor of N; \6=\5-1
)
# We want to capture \5 + \5/\3 + \5/\3^2 + ... + \3^2 + \3 + 1 = (\5*\3 - 1) / (\3 - 1),
# but in case \5 * \3 > N we need to calculate it as (\5 - 1) / (\3 - 1) * \3 + 1.
# The following division will fail if \5 == N, but that's fine, because no prime power is
# abundant.
(?=
  (x(x*))                   # \7 = (\5 - 1) / \4; \8 = \7-1
  .*(?=\6$)
  # It is guaranteed that either \7 > \4 or \7 == 1, which allows the following
  # division-by-multiplication to work.
  (?=\7*$)
  \4\8+$
)
(?=
  (.*)                      # \9 = tool to compare against \10
  (                         # \10 = \7*\3  =  (\5 - 1) / (\3 - 1)*\3; later, \12 = \10+1
    (?=\7*$)
    \3\8+$
  )
)
# Calculate Q = \14{2} + Q_R = floor(2 * N / \12). Since we don't have space for 2*N, we
# need to calculate N / \12 first, including the fractional part (i.e. the remainder),
# and then multiply the result, including the fractional part, by 2.
(?=
  (x*?)(?=(x\10)+$)         # \11 = N % \12; \12 = \10 + 1
  (?=\11\9|(x))             # \13 = Q_R = floor(\11 * 2 / \12)
                            #     = +1 carry if \11 * 2 > \10, or NPCG otherwise
  (x(x*))                   # \14 = N / \12; \15 = \14-1
  (?=\14*$)
  (?=\10+$)                 # must match if \14 <  \12; otherwise doesn't matter
  \10\15+$                  # must match if \14 >= \12; otherwise doesn't matter
)
# Calculate \16 = N / \5. The division by \5 can be done quite simply, because the divisor
# is a prime power.
(?=
  (x(x*))                   # \16 = N / \5; \17 = \16-1
  (?=\16*$)
  \6\17+$
)
# Seed a loop which will start with Q and divide it by (P^(K+1)-1)/(P-1) for every P^K
# that is a factor of \16. The state is encoded as \16 * P + R, where the initial value
# of R is Q, and P is the last prime factor of N to have been already processed.
# 
# However, since the initial R would be larger than \16 (and for that matter there would
# be no room for any nonzero R since with the initial value of P, it is possible for
# \16 * P to equal N), treat it as a special case, and let the initial value of R be 0,
# signalling the first iteration to pretend R=Q. This way we can avoid having to divide Q
# and \16 again outside the loop.
# 
# While we're at it, there's really no reason to do anything to seed this loop. To seed
# it with an initial value of P=\3, we'd have to do some multiplication. If we don't do
# anything to seed it, it will decode P=\5. That is wrong, but harmless, since the next
# lower prime that \16 is divisible by will still be the same, as \3 cannot be a factor
# of \16.

# Start the loop.
(
  (?=
    (                       # \19 = actual value of R
      x*?(?=\16+$)          # move forward by directly decoded value of R, which can be 0
      # The division by \16 can be done quite simply, because it is known that
      # the quotient is prime.
      (?=
        \16+?               # tail = \16 * (a prime which divides into \16)
        (?=
          (                 # \20 = encoded value for next loop iteration
            (xx(x*))        # \21 = decoded value of next smaller P; \22 = (\21-1)-1
            (?=\17+$)       # iff \21 > \16, this can have a false positive, but never a false negative
            \21*$           # iff \21 < \16, this can have a false positive, but never a false negative
          )
        )
        # Find the largest power of \21 that is a factor of \16, while also asserting
        # that \21 is prime.
        (x+)                # \23 = the largest power of \21 that is a factor of \16
        .*(?=\16$)
        \23*(?=\23$)
        (?!
          (xx+)\24*
          (?!\21+$)
          \24$
        )
        \21+$
      )
      (
        (?=\5+$)            # True iff this is the first iteration of the loop.
        \14{2}\13           # Potentially unset capture, and thus dependent on ECMAScript
                            # behavior. Change "\13" to "\13?" for compatibility with non-
                            # ECMAScript engines, so that it will act as an empty capture
                            # with engines in which unset backrefs always fail to match.
      |
      )
    )
  )
  # Calculate \28 = (\23 - 1) / (\21 - 1) * \21 + 1
  (?=
    .*(?=\23)x              # tail = \23 - 1
    (x(x*))                 # \26 = (\23 - 1) / (\21 - 1); \27 = \26-1
    (?=\26*$)
    \22\27*$
  )
  (?=
    .*(x(                   # \28 = 1 + \26*\21 = (\26-1) / (\21-1)*\21 + 1; \29 = \28-1
      (?=\26*$)
      \21\27+$
    ))
  )
  # Calculate \31 = floor(\19 / \28)
  (
    .*(?!\28)\19            # if dividing \19 / \28 would result in a number less than 1,
                            #  then N is abundant and we can exit the loop successfully
  |
    (?=
      .*?(?!x\19)(?=\28*$)
      (x(x*))               # \31 = \19 / \28; \32 = \31-1
      (?=\31*$)
      (?=\29+$)             # must match if \31 <  \28; otherwise doesn't matter
      \29\32+$              # must match if \31 >= \28; otherwise doesn't matter
    )
    # Encode the state for the next iteration of the loop, as \16 * \21 + \31
    .*(?=\31\20$)
  )
)+$