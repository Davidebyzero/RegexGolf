(?# Match correct multiplication statements in the domain ^x+\*x+=x+$ using only the ECMAScript subset of regex functionality )

(?# \1 = first factor; \2 = second factor; P = number we're testing as the potential product of \1 * \2 )
^(?=(x*)\*(x*)=)
[^=]*\b(?=(\1(x*))\b)(?=\2(x*)\b)  (?# \4 + \5 is the absolute value of \1 - \2, and is used below as \4\5; and, \3 is the larger of \1 and \2 )
(?:
    (?# Multiplication by 1 has to be treated as a special case, for two reasons. First, the method for calculating the largest prime power factor of \1 and \2 would need to be
        given a special case for if it equals P, because the main algorithm that is in use requires two copies of the factor to fit into \1 or \2, i.e., it must be no more than
        half of \1 or \2. Secondly, and most of all, even if the prime power factors of \1 and \2 were correctly calculated, the sum of them would not fit into P. )
    (?=x\4\5\b).*=\3$  (?# matches if \1==1 and \2==P, or \2==1 and \1==P )
|
    (?=.*=\3\3)  (?# if neither \1 nor \2 is 1, then P must be >= the double of either of them; and without this check, the test below could give a false positive )
    (?!
        x\4\5\b  (?# Multiplication by 1 has to be treated as a special case; see above )
    |
        (?# Our negative-lookahead statement here is: there does not exist a prime factor of either \1 or \2 for which the corresponding
            largest prime power factor of P is not equal to the product of the corresponding prime power factors of \1 and \2. )
        (?# Iterate \6 through all the prime factors possessed by \1 or \2; use |\4\5 to allow either \1 or \2 to have the prime factor )
        (xx+)(?:|\4\5)\6*\b.*=(?!.*(?=\6$)(xx+)\7+$)
        (?=(\6+|x)(?=.*(?=\1$)\ 8+$)(?!.*(?=\ 8$)((x+)(?=\10+$)x+)\ 9*(?!\10+$)\ 9$))  (?# \ 8 = the largest power of \6 that is a factor of \1 - use prime power test to find it )
        (?=(\6+|x)(?=.*(?=\2$)\11+$)(?!.*(?=\11$)((x+)(?=\13+$)x+)\12*(?!\13+$)\12$))  (?# \11 = the largest power of \6 that is a factor of \2 - use prime power test to find it )
        (?=(                                                                           (?# \14 = the largest power of \6 that is a factor of P )
            (?!((x+)(?=\16+$)x+)\15*(?!\16+$)\15$)\6+$                                 (?# if P itself is a prime power, the formula below wouldn't work, so it must be treated as a special case )
        |
            (?=(\6+|x)(?=     \17+$)(?!.*(?=\17$)((x+)(?=\19+$)x+)\18*(?!\19+$)\18$))\17   (?# otherwise, use the same formula to get \14 as was used for \8 and \11 )
        ))
        (
            (?!.*(?=\14$)(?=\8)\11)   (?# if neither \1 nor \2 is 1, then \14 must be >= both \8 and \11 if P is the product of \1 and \2; and without this check, the test below could give a false positive )
        |
            (?# Now we need to test if \8 * \11 == \14. To do this, we divide both \8 and \14 by \6, in a loop, until one of them equals 1, and then test to see if
                the resulting divided-down \14 is equal to \11. To do this we will need to encode \8 and \14 into a single number, \8 + \14, which must fit into P
                as a temporary variable so that we can operate on it. )
            (?# This algorithm would fail in the case that \1, \2, and P are all prime powers of the same prime, because \1 + P > P, and equivalently, \8 + \14 > P.
                So, just in this case we're in that situation, pre-divide \8 and \14 by \6 before going into the loop, unless one of them is 1. )
            (?=.*(?=\ 8$)(          x$ | (x+)(?=\22+$) ))  (?# \21 = \8==1 ?  \8 :  \8 / \6;  the division by \6 is implicit )
            (?=.*(?=\14$)( x*(?=\8$)x$ | (x+)(?=\24+$) ))  (?# \23 = \8==1 ? \14 : \14 / \6;  the division by \6 is implicit )
            (?# So that we can operate on both \21 and \23 in a loop -- which in a regex can only change the value of one number every iteration, and only in the direction of subtracting
                from it or keeping it the same -- encode it into a single number, as \21 + \23. This is unambiguous; if a number is the sum of two prime powers of the same prime, there is
                only one unique pair of prime powers of that prime that will have that sum. )
            (?=.*(?=\21\23$)
                (
                    (?# The first thing we need to do every iteration is decode the current number back into two prime powers, \26 and \29, where \26 is the smaller one, if they are different )
                    (?=(x|\6+?)(?!((x+)(?=\28+$)x+)\27*(?!\28+$)\27$)(\6+|x)$)
                    (
                        (?=.*(?=\26$)(x+)\31+$)  (?# \31 = \26 divided by its smallest factor, which implicitly must be \6 )
                        (?=.*(?=\29$)(x+)\32+$)  (?# \32 = \29 divided by its smallest factor, which implicitly must be \6 )
                        .*(?=\31\32$)            (?# return \31 + \32 as the new number to operate on in the next iteration of this loop )
                        |                        (?# if either \26 or \29 is 1, then this loop would fail on its first iteration; force it to succeed in this case, so \29 is captured for use outside the loop )
                    )
                )*
            )
            (?!.*(?=\29$)\11$)  (?# The above algorithm culminates here: this tests if after dividing \8 and \14 by \6 repeatedly until one of them is 1, the larger result, \29, equals \11.
                                    Implicit is the assumption that the larger result, \29, corresponds to \14. This is guaranteed due to other checks that were done earlier. )
        )
    |
        (?# Our negative-lookahead statement here is: there does not exist a prime factor of P that is not also a factor of either \1 or \2. )
        .*=(xx+)(?=\33*(?!(xx+)\34+$)\33$)  (?# \33 = a prime factor of P smaller than P )
        (?!.*(?=\1$|\2$)\33+$)              (?# return a non-match if \33 is not a factor of either \1 or \2 )
    )
)
